<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter2: Software Process</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

</head>

<body class="bg-gradient-to-br from-gray-900 via-gray-800 to-black text-gray-100 font-poppins leading-relaxed">

    <!-- Header Section -->
    <header class="bg-gradient-to-r from-orange-500 to-yellow-400 text-white shadow-lg sticky top-0 z-50 font-poppins">
        <section class="max-w-6xl mx-auto px-6 py-4 flex items-center font-poppins justify-between">
            <div class="max-w-6xl mx-auto flex flex-col sm:flex-row items-center justify-between p-4 sm:px-8">
                <h1 class="text-2xl md:text-3xl font-extrabold text-primary tracking-tight">Chapter 2: <span class="text-accent">Software Process</span></h1>
            </div>
        </section>

        <!-- Navigation Links -->
        <nav class="mt-2 sm:mt-0 space-x-4 text-sm md:text-base font-medium text-primary font-poppins">
            <ul class="flex flex-wrap justify-center space-x-6 py-3 text-lg font-medium">
                <li>
                <a href="#section-2.1" class=" hover:text-orange-600 hover:underline transition duration-200">
                    <b>2.1</b> Software Process Models
                </a>
                </li>

                <li>
                <a href="#section-2.2" class=" hover:text-orange-600 hover:underline transition duration-200">
                    <b>2.2</b> Process Activities
                </a>
                </li>

                <li>
                <a href="#section-2.3" class=" hover:text-orange-600 hover:underline transition duration-200">
                    <b>2.3</b> Coping With Change
                </a>
                </li>

                <li>
                <a href="#section-2.4" class=" hover:text-orange-600 hover:underline transition duration-200">
                    <b>2.4</b> The Rational Unified Process
                </a>
                </li>

            </ul>
        </nav>
    </header>

<!-- Main Content -->
<main class="max-w-6xl mx-auto px-6 md:px-8 py-12 space-y-20 fade-in-up font-poppins">
        <!-- Section 1 -->
        <section>
            <article class="space-y-4">
                <h1 class="text-4xl md:text-5xl font-extrabold text-primary font-poppins border-l-8 border-secondary pl-5 leading-tight">What is Software Process?</h1>
                <p class="text-lg md:text-xl text-white-700 text-justify font-poppins">
                A <b>software process</b> is a set of related activities that leads to the production of a software product. These activities may involve developing software from scratch in languages like Java or C. However, modern business applications often extend existing systems or integrate off-the-shelf software components.
                </p>
            </article>
        </section>

        <!-- Section 2 -->
        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 bg-[length:200%_200%] animate-gradientMove p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-700 ease-in-out transform hover:-translate-y-2 hover:scale-105 backdrop-blur-md border border-white/20 font-poppins">
            <article>
                <h1 class="text-3xl font-bold text-orange-700 mb-6 tracking-tight font-poppins">Four Activities Fundamental to Software Engineering</h1>
            </article>

            <article class="gap-8 text-gray-700 text-justify">
                <div>
                    <ol class="ol">
                        <li><b>Software specification:</b> The functionality and constraints of the software are defined.</li>
                        <li><b>Software design and implementation:</b> The software is produced according to the specification.</li>
                        <li><b>Software validation:</b> Ensures the software meets the customer's needs.</li>
                        <li><b>Software evolution:</b> The software evolves to meet changing requirements.</li>
                    </ol>
                </div> 
            </article>

            <article class="mt-6 space-y-3 text-gray-700 font-poppins">
                <p>These activities are part of all software processes, though each involves complex sub-activities such as requirements validation and unit testing. Supporting activities like documentation and configuration management are also vital.</p>
                <p>Process descriptions may also include:</p>
                <ul class="list-disc list-inside space-y-2 pl-4">
                    <li><b>Products:</b> Outcomes of a process activity</li>
                    <li><b>Roles:</b> Responsibilities of the people involved</li>
                    <li><b>Pre- and post-conditions:</b> Statements that are true before and after a process activity</li>
                </ul>
            </article>
        </section>

        <!-- Section 3 -->
        <section>
            <article class="gap-8 items-center text-justify font-poppins">
                <div class="space-y-4 text-justify">
                    <p>Software processes are complex and depend on human judgment. There is no single ideal process — most organizations adapt processes to their systems and people. For critical systems, a structured process is used, while for business systems, flexibility is key.</p>
                    <p>Software processes are categorized as either <b>plan-driven</b> or <b>agile</b>. Plan-driven processes are planned in advance, while agile methods emphasize adaptability.</p>
                    <p>Process improvement can be achieved through <b>standardization</b>, which enhances communication, reduces training time, and supports automation.</p>
                </div>
            </article>
        </section>

        <!-- Section 4 -->
        <section id="section-2.1" class="scroll-mt-24 slide-in font-poppins">
            <article class="mb-6">
                <h1 class="text-4xl font-bold text-orange-600 border-b-4 border-orange-500 pb-3">
                <a href="#section-2.1" class="hover:text-orange-700 transition-colors duration-200">2.1 Software Process Models</a>
                </h1>
            </article>

            <article class="space-y-4 text-white-700 font-poppins">
                <p>A <b>software process model</b> is a simplified representation of a software process, showing certain perspectives like activities or roles. These models serve as frameworks for understanding and improving software development.</p>
                <p>The main process models include:</p>

                <ol class="list-decimal list-inside space-y-3 ">
                <li><b>The Waterfall Model:</b> Divides development into phases such as requirements, design, implementation, and testing.</li>
                <li><b>Incremental Development:</b> Builds the system in a series of versions, each adding functionality.</li>
                <li><b>Reuse-Oriented Software Engineering:</b> Focuses on integrating existing reusable components.</li>
                </ol>
            </article>

            <article class="space-y-4 text-white-700 font-poppins mt-6">
                <p>Large systems often combine different models. For instance, core requirements might use a waterfall approach, while user interfaces are developed incrementally.</p>
            </article>
        </section>
       
        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="my-8">
                <img src="Chapter2-Images/Capture2.PNG" alt="Software Process Models Diagram" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500">
            </article>
            <article  class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 font-poppins">2.1.1 The Waterfall Model</h4>
            </article>
            <article class="space-y-4 text-black text-justify font-poppins">
                <p>The first published model of the software development process was derived from more general system engineering processes (Royce, 1970). This model is illustrated in Figure 2.1. Because of the cascade from one phase to another, this model is known as the ‘waterfall model’ or software life cycle. The waterfall model is an example of a plan-driven process—in principle, you must plan and schedule all of the process activities before starting work on them.</p>
                <p><b>Principal Stages of the Waterfall Model Directly Reflect the Fundamental Development Activities:</b></p>
            </article>
                <ol class="list-decimal list-inside space-y-3 text-black text-justify font-poppins mt-6">
                    <li><b>Requirements analysis and definition: </b> The system’s services, constraints, and goals are established by consultation with system users. They are then defined in detail and serve as a system specification.</li>
                    <li><b>System and software design: </b> The systems design process allocates the requirements to either hardware or software systems by establishing an overall system architecture. Software design involves identifying and describing the fundamental software system abstractions and their relationships</li>
                    <li><b>Implementation and unit testing: </b> During this stage, the software design is realized as a set of programs or program units. Unit testing involves verifying that each unit meets its specification.</li>
                    <li><b>Integration and system testing: </b> The individual program units or programs are integrated and tested as a complete system to ensure that the software requirements have been met. After testing, the software system is delivered to the customer.</li>
                    <li><b>Operation and maintenance: </b> Normally (although not necessarily), this is the longest life cycle phase. The system is installed and put into practical use. Maintenance involves correcting errors which were not discovered in earlier stages of the life cycle, improving the implementation of system units and enhancing the system’s services as new requirements are discovered.</li>
                </ol>
            <article class=" text-align-justfy mt-4 space-y-3 text-black font-poppins text-justify">
                <p>In principle, the result of each phase is one or more documents that are approved (‘signed off’). The following phase should not start until the previous phase has finished. In practice, these stages overlap and feed information to each other. During design, problems with requirements are identified. During coding, design problems are found and so on. The software process is not a simple linear model but involves feedback from one phase to another. Documents produced in each phase may then have to be modified to reflect the changes made.</p>
                <p>Because of the costs of producing and approving documents, iterations can be costly and involve significant rework. Therefore, after a small number of iterations, it is normal to freeze parts of the development, such as the specification, and to continue with the later development stages. Problems are left for later resolution, ignored, or programmed around. This premature freezing of requirements may mean that the system won’t do what the user wants. It may also lead to badly structured systems as design problems are circumvented by implementation tricks.</p>
                <p>During the final life cycle phase (operation and maintenance) the software is put into use. Errors and omissions in the original software requirements are discovered. Program and design errors emerge and the need for new functionality is identified. The system must therefore evolve to remain useful. Making these changes (software maintenance) may involve repeating previous process stages.</p>
                <p>The waterfall model is consistent with other engineering process models and documentation is produced at each phase. This makes the process visible so managers can monitor progress against the development plan. Its major problem is the inflexible partitioning of the project into distinct stages. Commitments must be made at an early stage in the process, which makes it difficult to respond to changing customer requirements.</p>
                <p>In principle, the waterfall model should only be used when the requirements are well understood and unlikely to change radically during system development. However, the waterfall model reflects the type of process used in other engineering projects. As is easier to use a common management model for the whole project, software processes based on the waterfall model are still commonly used.</p>
                <p>An important variant of the waterfall model is formal system development, where a mathematical model of a system specification is created. This model is then refined, using mathematical transformations that preserve its consistency, into executable code. Based on the assumption that your mathematical transformations are correct, you can therefore make a strong argument that a program generated in this way is consistent with its specification</p>
                <p>Formal development processes, such as that based on the B method (Schneider, 2001; Wordsworth, 1996) are particularly suited to the development of systems that have stringent safety, reliability, or security requirements. The formal approach simplifies the production of a safety or security case. This demonstrates to customers or regulators that the system actually meets its safety or security requirements.</p>
                <p>Processes based on formal transformations are generally only used in the development of safety-critical or security-critical systems. They require specialized expertise. For the majority of systems this process does not offer significant cost benefits over other approaches to system development.</p>
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 font-poppins">2.1.2 Incremental Development</h4>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>Based on the idea of developing an initial implementation, exposing this to user comment and evolving it through several versions until an adequate system has been developed (Figure 2.2). Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across activities<p>
                <p>Based on the idea of developing an initial implementation, exposing this to user comment and evolving it through several versions until an adequate system has been developed (Figure 2.2). Specification, development, and<p>
                <p>validation activities are interleaved rather than separate, with rapid feedback across activities</p>
                <p><b>Incremental software development</b>, which is a fundamental part of agile approaches, is better than a waterfall approach for most business, e-commerce, and personal systems. Incremental development reflects the way that we solve problems. We rarely work out a complete problem solution in advance but move toward a solution in a series of steps, backtracking when we realize that we have made a mistake. By developing the software incrementally, it is cheaper and easier to make changes in the software as it is being developed.</p>
                <p>Each increment or version of the system incorporates some of the functionality that is needed by the customer. Generally, the early increments of the system include the most important or most urgently required functionality. This means that the customer can evaluate the system at a relatively early stage in the development to see if it delivers what is required. If not, then only the current increment has to be changed and, possibly, new functionality defined for later increments.</p>
                <p><b>Incremental development has three important benefits, compared to the waterfall model:</b></p>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture.PNG" alt="Incremental Development Models" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500">
            </article>

            <article class=" text-align-justfy mt-4 space-y-3 text-justify text-black font-poppins">
                <ol class="list-decimal list-inside space-y-3 text-justify">
                    <li>The cost of accommodating changing customer requirements is reduced. The amount of analysis and documentation that has to be redone is much less than is required with the waterfall model.</li>
                    <li>It is easier to get customer feedback on the development work that has been done. Customers can comment on demonstrations of the software and see how much has been implemented. Customers find it difficult to judge progress from software design documents.</li>
                    <li>More rapid delivery and deployment of useful software to the customer is possible, even if all of the functionality has not been included. Customers are able to use and gain value from the software earlier than is possible with a waterfall process.</li>
                </ol>
            </article>

            <article class="glass p-6 anim-slide">
                <p class="text-justify text-black font-poppins">Incremental development in some form is now the most common approach for the development of application systems. This approach can be either plan-driven, agile, or, more usually, a mixture of these approaches. In a plan-driven approach, the system increments are identified in advance; if an agile approach is adopted, the early increments are identified but the development of later increments depends on progress and customer priorities.</p>
            </article>

            <article class=" text-align-justfy mt-4 space-y-3 text-justify text-black font-poppins">
            <p class="font-semibold" style="color:var(--primary)">From a management perspective, the incremental approach has two problems:</p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 space-y-3 text-black text-justify font-poppins">
                <li><b>Process visibility:</b> Managers need regular deliverables to measure progress. Rapid development can make producing documents for every version costly and impractical.</li>
                <li><b>Architectural degradation:</b> System structure can degrade as increments accumulate unless time and resources are dedicated to refactoring and architecture maintenance, making future changes more costly.</li>
                </ol>
            </article>

            <article class="glass p-6 anim-fade">
                <p class="text-justify text-black font-poppins">These problems become particularly acute for large, complex, long-lived systems developed by multiple teams. Such systems require a stable architecture and clearly defined team responsibilities; some aspects must therefore be planned in advance rather than developed purely incrementally.</p>
                <p class="mt-4 text-justify text-black font-poppins">Incremental development can be combined with staged deployment (incremental delivery) where users interact with deployed increments in production. While this enables real operational feedback, it can disrupt normal processes and is not always feasible. The advantages and disadvantages of incremental delivery are discussed in Section 2.3.2.</p>
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="my-8">
                <img src="Chapter2-Images/Capture3.PNG" alt="Reuse-Oriented Software Engineering Diagram" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 mt-6 font-poppins">2.1.3 Reuse-Oriented Software Engineering</h4>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 space-y-3 text-black text-justify font-poppins">
                    <li><b>Component analysis:</b> Given the requirements specification, a search is made for components to implement that specification. Usually, there is no exact match and the components that may be used only provide some of the functionality required.</li>
                    <li><b>Requirements modification: </b> During this stage, the requirements are analyzed using information about the components that have been discovered. They are then modified to reflect the available components. Where modifications are impossible, the component analysis activity may be re-entered to search for alternative solutions.</li>
                    <li><b>System design with reuse: </b> During this phase, the framework of the system is designed or an existing framework is reused. The designers take into account the components that are reused and organize the framework to cater for this. Some new software may have to be designed if reusable components are not available.</li>
                    <li><b>Development and integration: </b> Software that cannot be externally procured is developed, and the components and COTS systems are integrated to create the new system. System integration, in this model, may be part of the development process rather than a separate activity.</li>
                </ol>
            </article>

            <article class="glass p-6 anim-fade text-black">
                <p class="text-justify text-black font-semibold" style="color:var(--primary)">Types of software components used in reuse-oriented processes:</p>
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-gray-800 text-justify">
                    <li>Web services that are developed according to service standards and which are available for remote invocation.</li>
                    <li>Collections of objects that are developed as a package to be integrated with a component framework such as .NET or J2EE.</li>
                    <li>Stand-alone software systems that are configured for use in a particular environment.</li>
                </ol>
            </article>

            <article class="p-4 text-black font-poppins">
                <p class="text-justify">Reuse reduces development effort, cost, and risk, and often accelerates delivery. However, it may force compromises in requirements and reduce control over evolution when external components change. For depth on reuse, see Chapters 16–19.</p>
            </article>
        </section>

        <section id="section-2.2" class="scroll-mt-24 slide-in">
            <article class="mb-6">
                <h1 class="text-4xl font-bold text-orange-600 border-b-4 border-orange-500 pb-3">
                <a href="#section-2.2" class="hover:text-orange-700 transition-colors duration-200">2.2 Process Activities</a>
                </h1>
            </article>
        
            <article class="space-y-4 text-white-700 text-justify">
                <p>Real software processes are interleaved sequences of technical, collaborative, and managerial activities with the overall goal of specifying, designing, implementing, and testing a software system. Software developers use a variety of different software tools in their work. Tools are particularly useful for supporting the editing of different types of document and for managing the immense volume of detailed information that is generated in a large software project.</p>
                <p>The four basic process activities of specification, development, validation, and evolution are organized differently in different development processes. In the waterfall model, they are organized in sequence, whereas in incremental development they are interleaved. How these activities are carried out depends on the type of software, people, and organizational structures involved. In extreme programming, for example, specifications are written on cards. Tests are executable and developed before the program itself. Evolution may involve substantial system restructuring or refactoring.</p>
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 mt-6">2.2.1 Software Specification</h4>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>Software specification or requirements engineering is the process of understanding and defining what services are required from the system and identifying the constraints on the system’s operation and development. Requirements engineering is a particularly critical stage of the software process as errors at this stage inevitably lead to later problems in the system design and implementation.</p>
                <p>The requirements engineering process (Figure 2.4) aims to produce an agreed requirements document that specifies a system satisfying stakeholder requirements. Requirements are usually presented at two levels of detail. End-users and customers need a high-level statement of the requirements; system developers need a more detailed system specification.</p>
                <p class="text-justify text-gray-800 font-semibold" style="color:var(--primary)">There are four main activities in the requirements engineering process:</p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li><b>Feasibility study: </b> An estimate is made of whether the identified user needs may be satisfied using current software and hardware technologies. The study considers whether the proposed system will be cost-effective from a business point of view and if it can be developed within existing budgetary constraints. A feasibility study should be relatively cheap and quick. The result should inform the decision of whether or not to go ahead with a more detailed analysis.</li>
                    <li><b>Requirements elicitation and analysis: </b> This is the process of deriving the system requirements through observation of existing systems, discussions with potential users and procurers, task analysis, and so on. This may involve the development of one or more system models and prototypes. These help you understand the system to be specified.</li>
                    <li><b>Requirements specification: </b> Requirements specification is the activity of translating the information gathered during the analysis activity into a document that defines a set of requirements. Two types of requirements may be included in this document. User requirements are abstract statements of the system requirements for the customer and end-user of the system; system requirements are a more detailed description of the functionality to be provided.</li>
                    <li><b>Requirements validation: </b>This activity checks the requirements for realism, consistency, and completeness. During this process, errors in the requirements document are inevitably discovered. It must then be modified to correct these problems.</li>
                </ol>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture4.PNG" alt="Software Specification Diagram" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="space-y-4 text-black text-justify">
                <p>Of course, the activities in the requirements process are not simply carried out in a strict sequence. Requirements analysis continues during definition and specification and new requirements come to light throughout the process. Therefore, the activities of analysis, definition, and specification are interleaved. In agile methods, such as extreme programming, requirements are developed incrementally according to user priorities and the elicitation of requirements comes from users who are part of the development team.</p>
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article  class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800">2.2.2 Software Design and Implementation</h4>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>The implementation stage of software development is the process of converting a system specification into an executable system. It always involves processes of software design and programming but, if an incremental approach to development is used, may also involve refinement of the software specification.</p>
                <p>A software design is a description of the structure of the software to be implemented, the data models and structures used by the system, the interfaces between system components and, sometimes, the algorithms used. Designers do not arrive at a finished design immediately but develop the design iteratively. They add formality and detail as they develop their design with constant backtracking to correct earlier designs.</p>
                <p>Figure 2.5 is an abstract model of this process showing the inputs to the design process, process activities, and the documents produced as outputs from this process.</p>
                <p>The diagram suggests that the stages of the design process are sequential. In fact, design process activities are interleaved. Feedback from one stage to another and consequent design rework is inevitable in all design processes.</p>
                <p>Most software interfaces with other software systems. These include the operating system, database, middleware, and other application systems. These make up the ‘software platform’, the environment in which the software will execute. Information about this platform is an essential input to the design process, as designers must decide how best to integrate it with the software’s environment. The requirements specification is a description of the functionality the software must provide and its performance and dependability requirements. If the system is to process existing data, then the description of that data may be included in the platform specification; otherwise, the data description must be an input to the design process so that the system data organization to be defined.</p>
                <p>The activities in the design process vary, depending on the type of system being developed. For example, real-time systems require timing design but may not include a database so there is no database design involved. <b>Figure 2.5 shows four activities that may be part of the design process for information systems:</b></p>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture5.PNG" alt="Software Design and Implementation" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2  text-black text-justify font-poppins">
                    <li><b>Architectural design: </b> Where you identify the overall structure of the system, the principal components (sometimes called sub-systems or modules), their relationships, and how they are distributed.</li>
                    <li><b>Interface design: </b> Where you define the interfaces between system components. This interface specification must be unambiguous. With a precise interface, a component can be used without other components having to know how it is implemented. Once interface specifications are agreed, the components can be designed and developed concurrently.</li>
                    <li><b>Component design: </b> Where you take each system component and design how it will operate. This may be a simple statement of the expected functionality to be implemented, with the specific design left to the programmer. Alternatively, it may be a list of changes to be made to a reusable component or a detailed design model. The design model may be used to automatically generate an implementation</li>
                    <li><b>Database design: </b>  Where you design the system data structures and how these are to be represented in a database. Again, the work here depends on whether an existing database is to be reused or a new database is to be created.</li>
                </ol>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>These activities lead to a set of design outputs, which are also shown in Figure 2.5. The detail and representation of these vary considerably. For critical systems, detailed design documents setting out precise and accurate descriptions of the system must be produced. If a model-driven approach is used, these outputs may mostly be diagrams. Where agile methods of development are used, the outputs of the design process may not be separate specification documents but may be represented in the code of the program.</p>
                <p>Structured methods for design were developed in the 1970s and 1980s and were the precursor to the UML and object-oriented design (Budgen, 2003). They rely on producing graphical models of the system and, in many cases, automatically generating code from these models. Model-driven development (MDD) or model-driven engineering (Schmidt, 2006), where models of the software are created at different levels of abstraction, is an evolution of structured methods. In MDD, there is greater emphasis on architectural models with a separation between abstract implementationindependent models and implementation-specific models. The models are developed in sufficient detail so that the executable system can be generated from them. I discuss this approach to development in Chapter 5.</p>
                <p>The development of a program to implement the system follows naturally from the system design processes. Although some classes of program, such as safety-critical systems, are usually designed in detail before any implementation begins, it is more common for the later stages of design and program development to be interleaved. Software development tools may be used to generate a skeleton program from a design. This includes code to define and implement interfaces, and, in many cases, the developer need only add details of the operation of each program component.</p>
                <p>Programming is a personal activity and there is no general process that is usually followed. Some programmers start with components that they understand, develop these, and then move on to less-understood components. Others take the opposite approach, leaving familiar components till last because they know how to develop them. Some developers like to define data early in the process then use this to drive the program development; others leave data unspecified for as long as possible.</p>
                <p>Normally, programmers carry out some testing of the code they have developed. This often reveals program defects that must be removed from the program. This is called debugging. Defect testing and debugging are different processes. Testing establishes the existence of defects. Debugging is concerned with locating and correcting these defects.</p>
                <p>When you are debugging, you have to generate hypotheses about the observable behavior of the program then test these hypotheses in the hope of finding the fault that caused the output anomaly. Testing the hypotheses may involve tracing the program code manually. It may require new test cases to localize the problem. Interactive debugging tools, which show the intermediate values of program variables and a trace of the statements executed, may be used to support the debugging process.</p>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture6.PNG" alt="Stages of Testing" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800">2.2.3 Software Validation</h4>
           </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>Software validation or, more generally, verification and validation (V&V) is intended to show that a system both conforms to its specification and that it meets the expectations of the system customer. Program testing, where the system is executed using simulated test data, is the principal validation technique. Validation may also involve checking processes, such as inspections and reviews, at each stage of the software process from user requirements definition to program development. Because of the predominance of testing, the majority of validation costs are incurred during and after implementation</p>
                <p>Except for small programs, systems should not be tested as a single, monolithic unit. Figure 2.6 shows a three-stage testing process in which system components are tested then the integrated system is tested and, finally, the system is tested with the customer’s data. Ideally, component defects are discovered early in the process, and interface problems are found when the system is integrated. However, as defects are discovered, the program must be debugged and this may require other stages in the testing process to be repeated. Errors in program components, say, may come to light during system testing. The process is therefore an iterative one with information being fed back from later stages to earlier parts of the process</p>
                <p><b>The stages in the testing process are:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li><b>Development testing: </b> The components making up the system are tested by the people developing the system. Each component is tested independently, without other system components. Components may be simple entities such as functions or object classes, or may be coherent groupings of these entities. Test automation tools, such as JUnit (Massol and Husted, 2003), that can re-run component tests when new versions of the component are created, are commonly used.</li>
                    <li><b>System testing: </b> System components are integrated to create a complete system. This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems. It is also concerned with showing that the system meets its functional and non-functional requirements, and testing the emergent system properties. For large systems, this may be a multi-stage process where components are integrated to form subsystems that are individually tested before these sub-systems are themselves integrated to form the final system.</li>
                    <li><b>Acceptance testing: </b> This is the final stage in the testing process before the system is accepted for operational use. The system is tested with data supplied by the system customer rather than with simulated test data. Acceptance testing may reveal errors and omissions in the system requirements definition, because the real data exercise the system in different ways from the test data. Acceptance testing may also reveal requirements problems where the system’s facilities do not really meet the user’s needs or the system performance is unacceptable.</li>
                </ol>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>Normally, component development and testing processes are interleaved. Programmers make up their own test data and incrementally test the code as it is developed. This is an economically sensible approach, as the programmer knows the component and is therefore the best person to generate test cases.</p>
                <p>If an incremental approach to development is used, each increment should be tested as it is developed, with these tests based on the requirements for that increment. In extreme programming, tests are developed along with the requirements before development starts. This helps the testers and developers to understand the requirements and ensures that there are no delays as test cases are created.</p>
                <p>When a plan-driven software process is used (e.g., for critical systems development), testing is driven by a set of test plans. An independent team of testers works from these pre-formulated test plans, which have been developed from the system specification and design. Figure 2.7 illustrates how test plans are the link between testing and development activities. This is sometimes called the V-model of development (turn it on its side to see the V).</p>
                <p>Acceptance testing is sometimes called ‘alpha testing’. Custom systems are developed for a single client. The alpha testing process continues until the system developer and the client agree that the delivered system is an acceptable implementation of the requirements.</p>
                <p>When a system is to be marketed as a software product, a testing process called ‘beta testing’ is often used. Beta testing involves delivering a system to a number of potential customers who agree to use that system. They report problems to the system developers. This exposes the product to real use and detects errors that may not have been anticipated by the system builders. After this feedback, the system is modified and released either for further beta testing or for general sale.</p>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture7.PNG" alt="Plan-driven Software Process" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 mt-6">2.2.4 Software Evolution</h4>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>The flexibility of software systems is one of the main reasons why more and more software is being incorporated in large, complex systems. Once a decision has been made to manufacture hardware, it is very expensive to make changes to the hardware design. However, changes can be made to software at any time during or after the system development. Even extensive changes are still much cheaper than corresponding changes to system hardware.</p>
                <p>Historically, there has always been a split between the process of software development and the process of software evolution (software maintenance). People think of software development as a creative activity in which a software system is developed from an initial concept through to a working system. However, they sometimes think of software maintenance as dull and uninteresting. Although the costs of maintenance are often several times the initial development costs, maintenance processes are sometimes considered to be less challenging than original software development.</p>
                <p>This distinction between development and maintenance is increasingly irrelevant. Hardly any software systems are completely new systems and it makes much more sense to see development and maintenance as a continuum. Rather than two separate processes, it is more realistic to think of software engineering as an evolutionary process (Figure 2.8) where software is continually changed over its lifetime in response to changing requirements and customer needs</p>
            </article>

        </section>

        <section id="section-2.3" class="scroll-mt-24 slide-in">
            <article class="mb-6">
                <h1 class="text-4xl font-bold text-orange-600 border-b-4 border-orange-500 pb-3">
                <a href="#section-2.3" class="hover:text-orange-700 transition-colors duration-200 font-poppins">2.3 Coping with Change</a></h1>
           </article>

           <article class="my-8">
                <img src="Chapter2-Images/Capture8.PNG" alt="System Evolution" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>
            
           <article class="space-y-4 text-white-700 text-justify font-poppins">
                <p>Change is inevitable in all large software projects. The system requirements change as the business procuring the system responds to external pressures and management priorities change. As new technologies become available, new design and implementation possibilities emerge. Therefore whatever software process model is used, it is essential that it can accommodate changes to the software being developed.</p>
                <p>Change adds to the costs of software development because it usually means that work that has been completed has to be redone. This is called rework. For example, if the relationships between the requirements in a system have been analyzed and new requirements are then identified, some or all of the requirements analysis has to be repeated. It may then be necessary to redesign the system to deliver the new requirements, change any programs that have been developed, and re-test the system.</p>
                <p><b>There are two related approaches that may be used to reduce the costs of rework:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-white-800 text-justify font-poppins">
                    <li><b>Change avoidance: </b> Where the software process includes activities that can anticipate possible changes before significant rework is required. For example, a prototype system may be developed to show some key features of the system to customers. They can experiment with the prototype and refine their requirements before committing to high software production costs.</li>
                    <li><b>Change tolerance: </b> Where the process is designed so that changes can be accommodated at relatively low cost. This normally involves some form of incremental development. Proposed changes may be implemented in increments that have not yet been developed. If this is impossible, then only a single increment (a small part of the system) may have to be altered to incorporate the change.</li>
                </ol>
            </article>

            <article class="space-y-4 text-white-700 text-justify font-poppins">
                <p>The notion of refactoring, namely improving the structure and organization of a program, is also an important mechanism that supports change tolerance. I discuss this in Chapter 3, which covers agile methods.</p>
            </article>

            <article class="image-css">
                <img src="Chapter 2 Images/Capture9.PNG" alt="">
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="my-8">
                <img src="Chapter2-Images/Capture9.PNG" alt="Prototype Development" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 font-family-base: 'Poppins' mt-6">2.3.1 Prototyping</h4>
           </article>

            <article  class="space-y-4 text-black text-justify font-poppins">
                <p>A prototype is an initial version of a software system that is used to demonstrate concepts, try out design options, and find out more about the problem and its possible solutions. Rapid, iterative development of the prototype is essential so that costs are controlled and system stakeholders can experiment with the prototype early in the software process</p>
                <p><b>A software prototype can be used in a software development process to help anticipate changes that may be required:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li>In the requirements engineering process, a prototype can help with the elicitation and validation of system requirements.</li>
                    <li>In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</li>
                </ol>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>System prototypes allow users to see how well the system supports their work. They may get new ideas for requirements, and find areas of strength and weakness in the software. They may then propose new system requirements. Furthermore, as the prototype is developed, it may reveal errors and omissions in the requirements that have been proposed. A function described in a specification may seem useful and well defined. However, when that function is combined with other functions, users often find that their initial view was incorrect or incomplete. The system specification may then be modified to reflect their changed understanding of the requirements.</p>
                <p>A system prototype may be used while the system is being designed to carry out design experiments to check the feasibility of a proposed design. For example, a database design may be prototyped and tested to check that it supports efficient data access for the most common user queries. Prototyping is also an essential part of the user interface design process. Because of the dynamic nature of user interfaces, textual descriptions and diagrams are not good enough for expressing the user interface requirements. Therefore, rapid prototyping with end-user involvement is the only sensible way to develop graphical user interfaces for software systems</p>
                <p>A process model for prototype development is shown in Figure 2.9. The objectives of prototyping should be made explicit from the start of the process. These may be to develop a system to prototype the user interface, to develop a system to validate functional system requirements, or to develop a system to demonstrate the feasibility of the application to managers. The same prototype cannot meet all objectives. If the objectives are left unstated, management or end-users may misunderstand the function of the prototype. Consequently, they may not get the benefits that they expected from the prototype development. </p>
                <p>The next stage in the process is to decide what to put into and, perhaps more importantly, what to leave out of the prototype system. To reduce prototyping costs and accelerate the delivery schedule, you may leave some functionality out of the prototype. You may decide to relax non-functional requirements such as response time and memory utilization. Error handling and management may be ignored unless the objective of the prototype is to establish a user interface. Standards of reliability and program quality may be reduced.</p>
                <p>The final stage of the process is prototype evaluation. Provision must be made during this stage for user training and the prototype objectives should be used to derive a plan for evaluation. Users need time to become comfortable with a new system and to settle into a normal pattern of usage. Once they are using the system normally, they then discover requirements errors and omissions.</p>
                <p>A general problem with prototyping is that the prototype may not necessarily be used in the same way as the final system. The tester of the prototype may not be typical of system users. The training time during prototype evaluation may be insufficient. If the prototype is slow, the evaluators may adjust their way of working and avoid those system features that have slow response times. When provided with better response in the final system, they may use it in a different way</p>
                <p>Developers are sometimes pressured by managers to deliver throwaway prototypes, particularly when there are delays in delivering the final version of the software. <b>However, this is usually unwise:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li>It may be impossible to tune the prototype to meet non-functional requirements, such as performance, security, robustness, and reliability requirements, which were ignored during prototype development.</li>
                    <li>Rapid change during development inevitably means that the prototype is undocumented. The only design specification is the prototype code. This is not good enough for long-term maintenance.</li>
                    <li>The changes made during prototype development will probably have degraded the system structure. The system will be difficult and expensive to maintain.</li>
                    <li>Organizational quality standards are normally relaxed for prototype development.</li>
                </ol>
            </article>
            
            <article class="space-y-4 text-black text-justify font-poppins">
                <p>Prototypes do not have to be executable to be useful. Paper-based mock-ups of the system user interface (Rettig, 1994) can be effective in helping users refine an interface design and work through usage scenarios. These are very cheap to develop and can be constructed in a few days. An extension of this technique is a Wizard of Oz prototype where only the user interface is developed. Users interact with this interface but their requests are passed to a person who interprets them and outputs the appropriate response.</p>
            </article>
        
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
             <article class="my-8">
                <img src="Chapter2-Images/Capture10.PNG" alt="Incremental Delivery" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 font-poppins mt-6">2.3.2 Incremental Delivery</h4>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>Incremental delivery (Figure 2.10) is an approach to software development where some of the developed increments are delivered to the customer and deployed for use in an operational environment. In an incremental delivery process, customers identify, in outline, the services to be provided by the system. They identify which of the services are most important and which are least important to them. A number of delivery increments are then defined, with each increment providing a sub-set of the system functionality. The allocation of services to increments depends on the service priority, with the highest-priority services implemented and delivered first.</p>
                <p>Once the system increments have been identified, the requirements for the services to be delivered in the first increment are defined in detail and that increment is developed. During development, further requirements analysis for later increments can take place but requirements changes for the current increment are not accepted.</p>
                <p>Once an increment is completed and delivered, customers can put it into service. This means that they take early delivery of part of the system functionality. They can experiment with the system and this helps them clarify their requirements for later system increments. As new increments are completed, they are integrated with existing increments so that the system functionality improves with each delivered increment.</p>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p><b>Incremental delivery has a number of advantages:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li>Customers can use the early increments as prototypes and gain experience that informs their requirements for later system increments. Unlike prototypes, these are part of the real system so there is no re-learning when the complete system is available.</li>
                    <li>Customers do not have to wait until the entire system is delivered before they can gain value from it. The first increment satisfies their most critical requirements so they can use the software immediately</li>
                    <li>The process maintains the benefits of incremental development in that it should be relatively easy to incorporate changes into the system.</li>
                    <li>As the highest-priority services are delivered first and increments then integrated, the most important system services receive the most testing. This means that customers are less likely to encounter software failures in the most important parts of the system.</li>
                </ol>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p><b>However, there are problems with incremental delivery:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li>Most systems require a set of basic facilities that are used by different parts of the system. As requirements are not defined in detail until an increment is to be implemented, it can be hard to identify common facilities that are needed by all increments.</li>
                    <li>Iterative development can also be difficult when a replacement system is being developed. Users want all of the functionality of the old system and are often unwilling to experiment with an incomplete new system. Therefore, getting useful customer feedback is difficult.</li>
                    <li>The essence of iterative processes is that the specification is developed in conjunction with the software. However, this conflicts with the procurement model of many organizations, where the complete system specification is part of the system development contract. In the incremental approach, there is no complete system specification until the final increment is specified. This requires a new form of contract, which large customers such as government agencies may find difficult to accommodate.</li>
                </ol>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>There are some types of system where incremental development and delivery is not the best approach. These are very large systems where development may involve teams working in different locations, some embedded systems where the software depends on hardware development and some critical systems where all the requirements must be analyzed to check for interactions that may compromise the safety or security of the system.</p>
                <p>These systems, of course, suffer from the same problems of uncertain and changing requirements. Therefore, to address these problems and get some of the benefits of incremental development, a process may be used in which a system prototype is developed iteratively and used as a platform for experiments with the system requirements and design. With the experience gained from the prototype, definitive requirements can then be agreed.</p>
            </article>
        </section>

        <section class="bg-gradient-to-br from-white/90 via-gray-100/80 to-gray-200/70 p-8 rounded-3xl shadow-xl hover:shadow-2xl transition-all duration-500 backdrop-blur-md border border-white/20 font-poppins">
            <article class="main-title mb-6">
                <h4 class="text-3xl font-semibold text-orange-800 font-poppins mt-6">2.3.3 Boehm's Spiral Model</h4>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>A risk-driven software process framework (the spiral model) was proposed by Boehm (1988). This is shown in Figure 2.11. Here, the software process is represented as a spiral, rather than a sequence of activities with some backtracking from one activity to another. Each loop in the spiral represents a phase of the software process. Thus, the innermost loop might be concerned with system feasibility, the next loop with requirements definition, the next loop with system design, and so on. The spiral model combines change avoidance with change tolerance. It assumes that changes are a result of project risks and includes explicit risk management activities to reduce these risks.</p>
                <p><b>Each loop in the spiral is split into four sectors:</b></p>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture11.PNG" alt="Boehm's Spiral Model" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-black text-justify font-poppins">
                    <li><b>Objective setting: </b> Specific objectives for that phase of the project are defined. Constraints on the process and the product are identified and a detailed management plan is drawn up. Project risks are identified. Alternative strategies, depending on these risks, may be planned.</li>
                    <li><b>Risk assessment and reduction: </b> For each of the identified project risks, a detailed analysis is carried out. Steps are taken to reduce the risk. For example, if there is a risk that the requirements are inappropriate, a prototype system may be developed.</li>
                    <li><b>Development and validation: </b> After risk evaluation, a development model for the system is chosen. For example, throwaway prototyping may be the best development approach if user interface risks are dominant. If safety risks are the main consideration, development based on formal transformations may be the most appropriate process, and so on. If the main identified risk is sub-system integration, the waterfall model may be the best development model to use.</li>
                    <li><b>Planning: </b> The project is reviewed and a decision made whether to continue with a further loop of the spiral. If it is decided to continue, plans are drawn up for the next phase of the project.</li>
                </ol>
            </article>

            <article class="space-y-4 text-black text-justify font-poppins">
                <p>The main difference between the spiral model and other software process models is its explicit recognition of risk. A cycle of the spiral begins by elaborating objectives such as performance and functionality. Alternative ways of achieving these objectives, and dealing with the constraints on each of them, are then enumerated. Each alternative is assessed against each objective and sources of project risk are identified. The next step is to resolve these risks by information-gathering activities such as more detailed analysis, prototyping, and simulation.</p>
                <p>Once risks have been assessed, some development is carried out, followed by a planning activity for the next phase of the process. Informally, risk simply means something that can go wrong. For example, if the intention is to use a new programming language, a risk is that the available compilers are unreliable or do not produce sufficiently efficient object code. Risks lead to proposed software changes and project problems such as schedule and cost overrun, so risk minimization is a very important project management activity. Risk management, an essential part of project management, is covered in Chapter 22.</p>
            </article>
        </section>

        <section id="section-2.4" class="scroll-mt-24 slide-in">
            <article class="mb-6">
                <h1 class="text-4xl font-bold text-orange-600 border-b-4 border-orange-500 pb-3">
                <a href="#section-2.4" class="hover:text-orange-700 transition-colors duration-200">2.4 The Rational Unified Process</a></h1>
            </article>

            <article class="space-y-4 text-white-700 text-justify">
                <p>The Rational Unified Process (RUP) (Krutchen, 2003) is an example of a modern process model that has been derived from work on the UML and the associated Unified Software Development Process (Rumbaugh, et al., 1999; Arlow and Neustadt, 2005). I have included a description here, as it is a good example of a hybrid process model. It brings together elements from all of the generic process models (Section 2.1), illustrates good practice in specification and design (Section 2.2) and supports prototyping and incremental delivery (Section 2.3).</p>
                <p><b>The RUP recognizes that conventional process models present a single view of the process. In contrast, the RUP is normally described from three perspectives:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-white-700 text-justify font-poppins">
                    <li>A dynamic perspective, which shows the phases of the model over time.</li>
                    <li>A static perspective, which shows the process activities that are enacted.</li>
                    <li>A practice perspective, which suggests good practices to be used during the process.</li>
                </ol>
            </article>

            <article class="space-y-4 text-white-700 text-justify font-poppins">
                <p>Most descriptions of the RUP attempt to combine the static and dynamic perspectives in a single diagram (Krutchen, 2003). I think that makes the process harder to understand, so I use separate descriptions of each of these perspectives.</p>
                <p>The RUP is a phased model that identifies four discrete phases in the software process. However, unlike the waterfall model where phases are equated with process activities, the phases in the RUP are more closely related to business rather than technical concerns. Figure 2.11 shows the phases in the RUP. <b>These are:</b></p>
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="ol">
                    <li><b>Inception: </b>The goal of the inception phase is to establish a business case for the system. You should identify all external entities (people and systems) that will interact with the system and define these interactions. You then use this information to assess the contribution that the system makes to the business. If this contribution is minor, then the project may be cancelled after this phase.</li>
                    <li><b>Elaboration: </b>The goals of the elaboration phase are to develop an understanding of the problem domain, establish an architectural framework for the system, develop the project plan, and identify key project risks. On completion of this phase you should have a requirements model for the system, which may be a set of UML use-cases, an architectural description, and a development plan for the software.</li>
                    <li><b>Construction: </b> The construction phase involves system design, programming, and testing. Parts of the system are developed in parallel and integrated during this phase. On completion of this phase, you should have a working software system and associated documentation that is ready for delivery to users.</li>
                    <li><b>Transition: </b> The final phase of the RUP is concerned with moving the system from the development community to the user community and making it work in a real environment. This is something that is ignored in most software process models but is, in fact, an expensive and sometimes problematic activity. On completion of this phase, you should have a documented software system that is working correctly in its operational environment.</li>
                </ol>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture12.PNG" alt="Rational Unified Model" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="space-y-4 text-white-700 text-justify font-poppins">
                <p>Iteration within the RUP is supported in two ways. Each phase may be enacted in an iterative way with the results developed incrementally. In addition, the whole set of phases may also be enacted incrementally, as shown by the looping arrow from Transition to Inception in Figure 2.12.</p>
                <p>The static view of the RUP focuses on the activities that take place during the development process. These are called workflows in the RUP description. There are six core process workflows identified in the process and three core supporting workflows. The RUP has been designed in conjunction with the UML, so the workflow description is oriented around associated UML models such as sequence models, object models, etc. The core engineering and support workflows are described in Figure 2.13.</p>
                <p>The advantage in presenting dynamic and static views is that phases of the development process are not associated with specific workflows. In principle at least, all of the RUP workflows may be active at all stages of the process. In the early phases of the process, most effort will probably be spent on workflows such as business modelling and requirements and, in the later phases, in testing and deployment.</p>
                <p>The practice perspective on the RUP describes good software engineering practices that are recommended for use in systems development. <b>Six fundamental best practices are recommended:</b></p>
            </article>

            <article class="my-8">
                <img src="Chapter2-Images/Capture13.PNG" alt="Static Workflow Rational Unified Model" class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
            </article>

            <article class="glass p-6 anim-fade">
                <ol class="list-decimal pl-6 mt-3 space-y-2 text-white-700 text-justify font-poppins">
                    <li><b>Develop software iteratively: </b> Plan increments of the system based on customer priorities and de</li>
                    <li><b>Manage requirements: </b> Explicitly document the customer’s requirements and keep track of changes to these requirements. Analyze the impact of changes on the system before accepting them.</li>
                    <li><b>Use component-based architectures: </b> Structure the system architecture into components, as discussed earlier in this chapter.</li>
                    <li><b>Visually model software: </b> Use graphical UML models to present static and dynamic views of the software.</li>
                    <li><b>Verify software quality: </b> Ensure that the software meets the organizational quality standards.</li>
                    <li><b>Control changes to software: </b> Manage changes to the software using a change management system and configuration management procedures and tools.</li>
                </ol>
            </article>

            <article class="space-y-4 text-white-700 text-justify font-poppins">
                <p>The RUP is not a suitable process for all types of development, e.g., embedded software development. However, it does represent an approach that potentially combines the three generic process models discussed in Section 2.1. The most important innovations in the RUP are the separation of phases and workflows, and the recognition that deploying software in a user’s environment is part of the process. Phases are dynamic and have goals. Workflows are static and are technical activities that are not associated with a single phase but may be used throughout the development to achieve the goals of each phase.</p>
            </article>
        </section>
    </main>

    <!-- Footer -->
  <footer class="bg-gradient-to-r from-orange-600 to-yellow-400 text-white mt-16 shadow-inner">
        <section class="max-w-7xl mx-auto px-6 py-12  md:grid-cols-2 gap-12 fade-in">

            <!-- Key Points -->
            <article>
                <h1 class="text-3xl font-extrabold mb-6 border-b-2 border-white pb-2">KEY POINTS</h1>
                <ol class="list-decimal list-inside space-y-3 text-white/90 leading-relaxed mb-8">
                <li>Software processes are the activities involved in producing a software system. Software process models are abstract representations of these processes.</li>
                <li>General process models describe the organization of software processes. Examples include the waterfall model, incremental development, and reuse-oriented development.</li>
                <li>Requirements engineering develops software specifications to communicate customer needs to developers.</li>
                <li>Design and implementation transform a requirements specification into an executable software system.</li>
                <li>Software validation checks that the system meets specifications and user needs.</li>
                <li>Software evolution involves changing systems to meet new requirements.</li>
                <li>Processes should include activities to cope with change, such as prototyping and iterative development.</li>
                <li>The Rational Unified Process (RUP) organizes development into phases while separating activities like analysis, design, and testing.</li>
                </ol>
            </article>

            <!-- Quick Navigation & Credits -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-12"></div>
            <div class="overflow-x-auto">
                <table class="min-w-full border border-white/30 text-white/90 text-base">
                    <thead class="bg-orange-700/70">
                        <h1 class="text-3xl font-extrabold mb-6 border-b-2 border-white pb-2">QUICK NAVIGATION</h1>
                    </thead>
                    <tbody>
                    <tr class="hover:bg-orange-800/30 transition">
                        <td class="border border-white/30 px-4 py-2 font-bold">2.1</td>
                        <td class="border border-white/30 px-4 py-2">
                        <a href="#section-2.1" class="sections-tb ">
                            Software Process Models
                        </a>
                        </td>
                    </tr>
                    <tr class="hover:bg-orange-800/30 transition">
                        <td class="border border-white/30 px-4 py-2 font-bold">2.2</td>
                        <td class="border border-white/30 px-4 py-2">
                        <a href="#section-2.2" class="sections-tb ">
                            Process Activities
                        </a>
                        </td>
                    </tr>
                    <tr class="hover:bg-orange-800/30 transition">
                        <td class="border border-white/30 px-4 py-2 font-bold">2.3</td>
                        <td class="border border-white/30 px-4 py-2">
                        <a href="#section-2.3" class="sections-tb ">
                            Coping With Change
                        </a>
                        </td>
                    </tr>
                    <tr class="hover:bg-orange-800/30 transition">
                        <td class="border border-white/30 px-4 py-2 font-bold">2.4</td>
                        <td class="border border-white/30 px-4 py-2">
                        <a href="#section-2.4" class="sections-tb ">
                            The Rational Unified Process
                        </a>
                        </td>
                    </tr>
                    </tbody>
                </table>
                </div>
            </div>

                <!-- Created By + Back to Top -->
                <div class="mt-10 border-t border-white/40 pt-4 flex items-center justify-between flex-wrap gap-4">
                    <p class="created-by">
                        Created by: <b>Mica Joyce Biadoy</b>
                    </p>
                    <a href="#top"
                        class="back-to-top">
                        ↑ Back to Top
                    </a>
                </div>
            </article>

        </section>

        <div class="bg-orange-700 text-center py-4 text-sm text-white/90">© 2025 Software Engineering Module | All Rights Reserved</div>
  </footer>
</body>
</html>
