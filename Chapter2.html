<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter2: Software Process</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="stylesheet" rel="./src/output.css">
    <link rel="icon" type="image/png" href="./index_images/image.png" />

</head>

<body class="bg-orange-50 text-amber-900 font-poppins leading-relaxed">
    
    <div class="fixed top-0 left-0 w-full h-1 bg-orange-600 z-[100]">
        <div class="animate-progress"></div>
    </div>
    
    <header class="sticky top-0 z-50 bg-gradient-to-r from-amber-50 via-white to-amber-50 backdrop-blur-md shadow-lg border-b border-amber-200">
        <div class="max-w-7xl mx-auto px-6 py-4 flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0">

                <h1 class="text-2xl md:text-3xl font-extrabold bg-gradient-to-r from-orange-600 via-amber-500 to-orange-600 bg-clip-text text-transparent ">
                <img src="index_images/image.png" class="inline-flex h-10 w-10 space-x-4 rounded-lg"> Software Engineering</h1>

            <nav class="w-full sm:w-auto">
                <ul class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-6 text-amber-900 font-semibold text-center sm:text-left">
                    
                    <li class="relative group" tabindex="0">
                        <a href="#section-2.1" class="inline-flex items-center justify-center w-full sm:w-auto hover:text-orange-700 transition duration-150 p-2 sm:p-0">
                            2.1 Process Models
                            <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </a>
            
                        <ul class="dropdown-menu absolute hidden sm:group-hover:block sm:group-focus-within:block top-full sm:mt-1 left-1/2 sm:left-0 transform -translate-x-1/2 sm:translate-x-0 w-60 bg-white rounded-xl shadow-2xl border border-amber-100 overflow-hidden z-20">
                            <li class="border-b border-amber-50/50"><a href="#section-2.1.1" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.1.1 The Waterfall Model</a></li>
                            <li class="border-b border-amber-50/50"><a href="#section-2.1.2" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.1.2 Incremental Development</a></li>
                            <li><a href="#section-2.1.3" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.1.3 Reuse-Oriented Software Engineering</a></li>
                        </ul>
                    </li>
                    
                    <li class="relative group" tabindex="0">
                        <a href="#section-2.2" class="inline-flex items-center justify-center w-full sm:w-auto hover:text-orange-700 transition duration-150 p-2 sm:p-0">
                            2.2 Process Activities
                            <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </a>
            
                        <ul class="dropdown-menu absolute hidden sm:group-hover:block sm:group-focus-within:block top-full sm:mt-1 left-1/2 sm:left-0 transform -translate-x-1/2 sm:translate-x-0 w-60 bg-white rounded-xl shadow-2xl border border-amber-100 overflow-hidden z-20">
                            <li class="border-b border-amber-50/50"><a href="#section-2.2.1" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.2.1 Software Specification</a></li>
                            <li class="border-b border-amber-50/50"><a href="#section-2.2.2" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.2.2 Software Design and Implementation</a></li>
                            <li><a href="#section-2.2.3" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.2.3 Software Validation</a></li>
                            <li><a href="#section-2.2.4" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.2.4 Software Evolution</a></li>
                        </ul>
                    </li>

                    <li class="relative group" tabindex="0">
                        <a href="#section-2.3" class="inline-flex items-center justify-center w-full sm:w-auto hover:text-orange-700 transition duration-150 p-2 sm:p-0">
                            2.3 Coping With Change
                            <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </a>
            
                        <ul class="dropdown-menu absolute hidden sm:group-hover:block sm:group-focus-within:block top-full sm:mt-1 left-1/2 sm:left-0 transform -translate-x-1/2 sm:translate-x-0 w-60 bg-white rounded-xl shadow-2xl border border-amber-100 overflow-hidden z-20">
                            <li class="border-b border-amber-50/50"><a href="#section-2.3.1" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.3.1 Prototyping</a></li>
                            <li class="border-b border-amber-50/50"><a href="#section-2.3.2" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.3.2 Incremental Delivery</a></li>
                            <li><a href="#section-2.3.3" class="block px-4 py-2 text-amber-800 hover:bg-amber-100 transition duration-150 text-sm">2.3.3 Boehm’s Spiral Model</a></li>
                        </ul>
                    </li>

                     <li class="relative group" tabindex="0">
                        <a href="#section-2.4" class="inline-flex items-center justify-center w-full sm:w-auto hover:text-orange-700 transition duration-150 p-2 sm:p-0">
                            2.4 The Rational Unified Process
                            <svg class="ml-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-6xl mx-auto px-6 md:px-8 py-12 space-y-20 fade-in-up font-poppins text-amber-900">
    
        <section>
            <article class="space-y-4">
            <h1 class="text-4xl md:text-5xl font-extrabold text-orange-700 border-l-8 border-yellow-500 pl-5 leading-tight">
                What is Software Process?
            </h1>
            <p class="text-lg md:text-xl text-justify">
                A <b>software process</b> is a set of related activities that leads to the production of a software product.
                These activities may involve developing software from scratch in languages like Java or C.
                However, modern business applications often extend existing systems or integrate off-the-shelf software components.
            </p>
            </article>
        </section>

        <section class="bg-gradient-to-br from-white via-yellow-50 to-amber-50 p-8 rounded-3xl shadow-md hover:shadow-lg transition-all duration-500 ease-in-out transform hover:-translate-y-1 hover:scale-[1.02] border border-amber-100">
            <article>
            <h1 class="text-3xl font-bold text-orange-700 mb-6 tracking-tight">
                Four Activities Fundamental to Software Engineering
            </h1>
            </article>

            <article class="gap-8 text-justify">
                <div>
                    <ol class="main-ol">
                    <li><b>Software specification:</b> The functionality and constraints of the software are defined.</li>
                    <li><b>Software design and implementation:</b> The software is produced according to the specification.</li>
                    <li><b>Software validation:</b> Ensures the software meets the customer's needs.</li>
                    <li><b>Software evolution:</b> The software evolves to meet changing requirements.</li>
                    </ol>
                </div> 
            </article>

            <article class="mt-6 space-y-3">
            <p>
                These activities are part of all software processes, though each involves complex sub-activities such as
                requirements validation and unit testing. Supporting activities like documentation and configuration management
                are also vital.
            </p>
            <p>Process descriptions may also include:</p>
            <ul class="main-ul">
                <li><b>Products:</b> Outcomes of a process activity</li>
                <li><b>Roles:</b> Responsibilities of the people involved</li>
                <li><b>Pre- and post-conditions:</b> Statements that are true before and after a process activity</li>
            </ul>
            </article>
        </section>


        <section>
            <article class="gap-8 items-center text-justify">
                <div class="text-lg md:text-xl text-justify">
                <p>
                Software processes are complex and depend on human judgment. There is no single ideal process —
                most organizations adapt processes to their systems and people. For critical systems, a structured process
                is used, while for business systems, flexibility is key.
                </p><br>
                <p>
                Software processes are categorized as either <b>plan-driven</b> or <b>agile</b>.
                Plan-driven processes are planned in advance, while agile methods emphasize adaptability.
                </p><br>
                <p>
                Process improvement can be achieved through <b>standardization</b>, which enhances communication,
                reduces training time, and supports automation.
                </p>
            </div>
            </article>
        </section>

        <section id="section-2.1" class="main-sec4">

            <article class="mb-8">
                <h1 class="main-con">
                <a href="#section-2.1" class="text-4xl md:text-5xl font-extrabold text-orange-700 border-l-8 border-yellow-500 pl-5 leading-tight">2.1 Software Process Models</a>
                </h1>
            </article>


            <article class="text-lg md:text-xl text-justify">
                <p>
                A <b>software process model</b> is a simplified representation of a software process, showing certain perspectives like activities or roles. These models serve as frameworks for understanding and improving software development.
                </p><br>
                <p>The main process models include:</p>

                <ol class="main-ol2">
                <li><b>The Waterfall Model:</b> Divides development into phases such as requirements, design, implementation, and testing.</li>
                <li><b>Incremental Development:</b> Builds the system in a series of versions, each adding functionality.</li>
                <li><b>Reuse-Oriented Software Engineering:</b> Focuses on integrating existing reusable components.</li>
                </ol>
            </article>

            <article class="text-lg md:text-xl text-justify mt-6">
                <p>Large systems often combine different models. For instance, core requirements might use a waterfall approach, while user interfaces are developed incrementally.</p>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture2.PNG"
                alt="Software Process Models Diagram"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.1: The Waterfall Model</p>
                <div class="div-img"></div>
            </article>

            <article id="section-2.1.1" class="main-sec4">
                <h4 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300"><a href="#section-2.1.1">2.1.1 The Waterfall Model</a></h4>
            </article>

            <article class="text-lg md:text-xl text-justify text-justify">
                <p>The first published model of the software development process was derived from more general system engineering processes (Royce, 1970). This model is illustrated in Figure 2.1. Because of the cascade from one phase to another, this model is known as the ‘waterfall model’ or software life cycle. The waterfall model is an example of a plan-driven process—in principle, you must plan and schedule all of the process activities before starting work on them.</p><br>
                <p><b>Principal Stages of the Waterfall Model Reflect the Fundamental Development Activities:</b></p><br>

                <ol class="main-ol2">
                    <li><b>Requirements analysis and definition:</b> The system’s services, constraints, and goals are established by consultation with users and documented in detail.</li><br>
                    <li><b>System and software design:</b> Requirements are allocated to system components, defining architecture and software abstractions.</li><br>
                    <li><b>Implementation and unit testing:</b> The design is realized through coding, and each unit is tested to meet specifications.</li><br>
                    <li><b>Integration and system testing:</b> Components are integrated and tested as a complete system to ensure requirements are met.</li><br>
                    <li><b>Operation and maintenance:</b> The system is deployed and maintained; errors are corrected, and enhancements are made as new requirements arise.</li>
                </ol>
                    <br>
                    <p>Each phase produces documentation that is reviewed and approved before the next phase begins. However, in practice, feedback loops occur — issues in design may lead to revisiting requirements, and testing can reveal design flaws. This iterative reality makes the process more dynamic than a simple linear flow.</p><br>
                    <p>The waterfall model is consistent with engineering discipline — structured, document-driven, and predictable. Its downside lies in inflexibility; adapting to changing requirements can be costly once stages are locked.</p><br>
                    <p>This model works best when requirements are stable and well understood from the start. It’s still widely used because it aligns with standard project management practices and offers visibility through documentation.</p><br>
                    <p>Variants like <b>formal system development</b> introduce mathematical precision to improve safety and reliability, making it suitable for mission-critical or security-critical systems.</p>
            </article>
        </section>

        <section id="section-2.1.2" class="main-sec4">

            <article class="mb-8">
                <h4 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">
                <a href="#section-2.1.2">2.1.2 Incremental Development</a>
                </h4>
            </article>

            <article class="text-lg md:text-xl text-justify text-justify">
                <p>Based on the idea of developing an initial implementation, exposing this to user comment, and evolving it through several versions until an adequate system has been developed (Figure 2.2). Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across activities.</p><br>
                <p><b>Incremental software development</b>, a key part of agile methodologies, is often superior to the waterfall model for business, e-commerce, and personal systems. It mirrors how we naturally solve problems — iteratively improving and adjusting with feedback.</p><br>
                <p>Each increment of the system includes essential customer functionality. Early increments focus on the most important requirements, allowing early evaluation and adjustment before full completion.</p><br>
                <p><b>Incremental development offers three main advantages over the waterfall model:</b></p>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture.PNG"
                alt="Incremental Development Model"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.2: Incremental Development</p>
                <div class="div-img"></div>
            </article>

            <article class="text-lg md:text-xl text-justify">
                <ol class="main-ol2">
                    <li>The cost of accommodating changing requirements is reduced, as less documentation must be redone.</li><br>
                    <li>Customer feedback is easier to obtain since users can evaluate partial implementations.</li><br>
                    <li>Useful software is delivered earlier, even before all functionality is complete.</li><br>
                </ol>
                <p>Incremental development is now the most common approach to system development — whether plan-driven, agile, or hybrid. Early increments may be planned in advance, while later ones adapt to user priorities.</p>
                <br>
                <p class="font-semibold text-orange-700">From a management perspective, two key challenges exist:</p><br>

                <ol class="main-ol2">
                    <li><b>Process visibility:</b> Without formal deliverables for each version, tracking progress can be difficult.</li><br>
                    <li><b>Architectural degradation:</b> As increments accumulate, system structure may degrade unless time is devoted to refactoring.</li>
                </ol>
                <br>
                <p>These challenges are most acute in large, complex systems involving multiple teams.Incremental development can also combine with staged deployment, where real user interaction provides valuable feedback.</p>
            </article>
        </section>

        <section id="section-2.1.3" class="main-sec4">

            <article class="mb-8">
                <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">
                <a href="#section-2.1.3">2.1.3 Reuse-Oriented Software Engineering</a>
                </h1>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture3.PNG"
                alt="Reuse-Oriented Software Engineering Diagram"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.3: Reuse-oriented Software Engineering</p>
                <div class="div-img"></div>
            </article>

            <article class="text-lg md:text-xl text-justify">
                <p>In reuse-oriented software engineering, systems are constructed using existing components rather than developing everything from scratch. This approach emphasizes efficient assembly over original design.</p>
                <br>
                <ol class="main-ol2">
                    <li><b>Component analysis:</b> Identify reusable components that can meet system requirements.</li><br>
                    <li><b>Requirements modification:</b> Adjust system requirements to align with available components.</li><br>
                    <li><b>System design with reuse:</b> Integrate selected components into a cohesive system architecture.</li><br>
                    <li><b>Development and integration:</b> Develop missing parts and integrate all reusable and new components into the final product.</li>
                </ol>
                <br>
                <p class="font-semibold text-orange-700">Types of software components used in reuse-oriented processes:</p>

                <ol class="main-ol2">
                    <li>Web services developed according to open service standards and accessible remotely.</li><br>
                    <li>Object collections packaged for frameworks such as .NET or J2EE.</li><br>
                    <li>Standalone software systems configured for specific operating environments.</li>
                </ol>
                <p>Reuse minimizes effort, cost, and risk while accelerating delivery. However, it may require compromises in requirements and reduce control over future updates when external components change. For detailed discussions, see Chapters 16–19.</p>
            </article>
        </section>

        <section id="section-2.2" class="main-sec4">
            <article class="mb-8">
                <h1 class="main-con">
                <a href="#section-2.2" class="text-4xl md:text-5xl font-extrabold text-orange-700 border-l-8 border-yellow-500 pl-5 leading-tight">2.2 Process Activities</a>
                </h1>
            </article>
        
            <article class="text-lg md:text-xl text-justify text-white-700">
                <p>Real software processes are interleaved sequences of technical, collaborative, and managerial activities with the overall goal of specifying, designing, implementing, and testing a software system. Software developers use a variety of different software tools in their work. Tools are particularly useful for supporting the editing of different types of document and for managing the immense volume of detailed information that is generated in a large software project.</p>
                <br>
                <p>The four basic process activities of specification, development, validation, and evolution are organized differently in different development processes. In the waterfall model, they are organized in sequence, whereas in incremental development they are interleaved. How these activities are carried out depends on the type of software, people, and organizational structures involved. In extreme programming, for example, specifications are written on cards. Tests are executable and developed before the program itself. Evolution may involve substantial system restructuring or refactoring.</p>
            </article>
        </section>

        <section id="section-2.2.1" class="main-sec4">
            <article class="mb-8">
                <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">
                2.2.1 Software Specification
                </h1>
            </article>

            <article class="text-lg md:text-xl text-justify">
                <p><b>Software specification</b> or requirements engineering is the process of understanding and defining what services are required from the system and identifying the constraints on its operation and development. Errors at this stage inevitably lead to later problems in system design and implementation.</p>
                <br>
                <p>The requirements engineering process aims to produce an agreed requirements document that specifies a system satisfying stakeholder needs. Requirements are usually presented at two levels of detail — high-level for customers and detailed for developers.</p>
                <p class="font-semibold text-gray-800">There are four main activities in the requirements engineering process:</p><br>

                <ol class="main-ol2">
                    <li><b>Feasibility study:</b> Estimates whether identified user needs can be met using current technology and within budget.</li><br>
                    <li><b>Requirements elicitation and analysis:</b> Derives system requirements through discussions, observation, and modeling.</li><br>
                    <li><b>Requirements specification:</b> Translates gathered information into a clear requirements document.</li><br>
                    <li><b>Requirements validation:</b> Checks requirements for consistency, realism, and completeness.</li>
                </ol>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture4.PNG"
                alt="Software Specification Diagram"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                 <p class="text-center text-sm text-amber-600 mt-3">Figure 2.4: The Requirements Engineering Process</p>
                 <div class="div-img"></div>
            </article>
        </section>

        <section  id="section-2.2.2" class="main-sec4">
            <article class="mb-8">
                <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">
                2.2.2 Software Design and Implementation
                </h1>
            </article>

            <article class="text-lg md:text-xl text-justify">
                <p>The implementation stage converts a system specification into an executable system. It involves both design and programming, and often overlaps when using incremental approaches.</p>
                <br>
                <p>A <b>software design</b> describes the system’s structure, data models, interfaces, and algorithms. Designers iteratively refine the design with constant backtracking to improve structure and correctness.</p>
                <br>
                <p>Feedback is an essential part of the design process — stages are interleaved, not strictly sequential.</p>

                <ol class="main-ol2">
                <li><b>Architectural design:</b> Defines the overall system structure and module relationships.</li><br>
                <li><b>Interface design:</b> Specifies interfaces between components, allowing independent development.</li><br>
                <li><b>Component design:</b> Defines internal operations of each system module.</li><br>
                <li><b>Database design:</b> Describes how data will be organized and stored in the system.</li>
                </ol>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture5.PNG"
                alt="Software Design and Implementation"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                  <p class="text-center text-sm text-amber-600 mt-3">Figure 2.5: A GeneraL Model of the Design Process</p>
                  <div class="div-img"></div>
            </article>
        </section>

        <section  id="section-2.2.1" class="main-sec4">
            <article id="section-2.2.3" class="mb-8">
                <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">
                2.2.3 Software Validation
                </h1>
            </article>

            <article class="text-lg md:text-xl text-justify">
                <p><b>Software validation</b> ensures that a system both conforms to its specification and meets customer expectations. Program testing is the main validation technique, supported by reviews and inspections.</p>
                <br>
                <p>Testing is not a single-step activity; it proceeds in multiple stages:</p>

                <ol class="main-ol2">
                <li><b>Development testing:</b> Tests individual components using automated tools.</li><br>
                <li><b>System testing:</b> Verifies that integrated components work together and meet system requirements.</li><br>
                <li><b>Acceptance testing:</b> Validates the final product with real user data before deployment.</li>
                </ol>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture6.PNG"
                alt="Software Evolution Diagram"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.6: Stages of Testing</p>
                <div class="div-img"></div>
            </article>
        </section>

        <section id="section-2.2.1" class="main-sec4">
            <article id="section-2.2.4"class="mb-8">
                <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">
                2.2.4 Software Evolution
                </h1>
            </article>

            <article class="text-lg md:text-xl text-justify">
                <p>The flexibility of software makes it easier and cheaper to modify compared to hardware. Over time, software evolves as new requirements emerge and technologies change.</p><br>
                <p>Historically, development and maintenance were treated separately, but now software engineering is viewed as an <b>evolutionary process</b> where systems are continually updated and improved throughout their lifetime.</p>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture7.PNG"
                alt="Software Validation Diagram"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                        grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.7: Testing Phases in a Plan-Driven Software Process</p>
                <div class="div-img"></div>
            </article>
        </section>

       <section  id="section-2.3" class="main-sec4">
            <article class="mb-8">
                <h1 class="main-con">
                    <a href="#section-2.3" class="text-4xl md:text-5xl font-extrabold text-orange-700 border-l-8 border-yellow-500 pl-5 leading-tight">
                        2.3 Coping with Change
                    </a>
                </h1>
            </article>

            <article class="text-lg md:text-xl text-justify text-white-700">
                <p>Change is inevitable in all large software projects. The system requirements change as the business procuring the system responds to external pressures and management priorities change. As new technologies become available, new design and implementation possibilities emerge. Therefore, whatever software process model is used, it is essential that it can accommodate changes to the software being developed.</p>
                <br>
                <p>Change adds to the costs of software development because it usually means that work that has been completed has to be redone. This is called <b>rework</b>. For example, if the relationships between the requirements in a system have been analyzed and new requirements are then identified, some or all of the requirements analysis has to be repeated. It may then be necessary to redesign the system to deliver the new requirements, change any programs that have been developed, and re-test the system.</p>
                <br>
                <p class="font-semibold text-orange-800">There are two related approaches that may be used to reduce the costs of rework:</p>
            </article>

            <article class="text-lg md:text-xl text-justify text-white-700">
                <ol class="list-decimal list-inside space-y-4"><br>
                    <li><b>Change avoidance:</b> Where the software process includes activities that can anticipate possible changes before significant rework is required. For example, a prototype system may be developed to show some key features of the system to customers. They can experiment with the prototype and refine their requirements before committing to high software production costs.</li>
                    <li>
                        <b>Change tolerance:</b> Where the process is designed so that changes can be accommodated at relatively low cost. This normally involves some form of incremental development. Proposed changes may be implemented in increments that have not yet been developed. If this is impossible, then only a single increment (a small part of the system) may have to be altered to incorporate the change.
                    </li>
                </ol>
            </article>

            <article class="text-lg md:text-xl text-justify text-white-700"><br>
                <p>
                    The notion of <b>refactoring</b>, namely improving the structure and organization of a program, is also an important mechanism that supports change tolerance. This topic is explored further in Chapter 3, which covers agile methods.
                </p>
            </article>

            <article class="my-12 relative group">
                <img src="Chapter2-Images/Capture8.PNG"
                    alt="System Evolution"
                    class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110 group-hover:shadow-2xl transform" />
                    <p class="text-center text-sm text-amber-600 mt-3">Figure 2.8: System Evolution</p>
                    <div class="div-img"></div>
            </article>
        </section>

    <section id="section-2.3.1" class="main-sec4">

        <article class="mb-8">
            <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">2.3.1 Prototyping</h1>
        </article>

        <article class="my-12 relative group">
            <img src="Chapter2-Images/Capture9.PNG"
                alt="Prototype Development"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                    grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110
                    group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.9: The Process of Prototype Development</p>
            <div class="div-img"></div>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <p>A <b>prototype</b> is an initial version of a software system that is used to demonstrate concepts, try out design options, and find out more about the problem and its possible solutions. Rapid, iterative development of the prototype is essential so that costs are controlled and system stakeholders can experiment with the prototype early in the software process.</p>
            <br>
            <p><b>A software prototype can be used in a software development process to help anticipate changes that may be required:</b></p>

            <ol class="list-decimal list-inside space-y-2 mt-3">
                <li>In the requirements engineering process, a prototype can help with the elicitation and validation of system requirements.</li>
                <li>In the system design process, a prototype can be used to explore particular software solutions and to support user interface design.</li>
            </ol>
        </article>

        <article class="text-lg md:text-xl text-justify mt-6 space-y-4">
            <p>System prototypes allow users to see how well the system supports their work. They may get new ideas for requirements, and find areas of strength and weakness in the software. They may then propose new system requirements. Furthermore, as the prototype is developed, it may reveal errors and omissions in the requirements that have been proposed.</p>
            <br>
            <p>A system prototype may be used while the system is being designed to carry out design experiments to check the feasibility of a proposed design. For example, a database design may be prototyped and tested to check that it supports efficient data access for the most common user queries.</p>
            <br>
            <p>A process model for prototype development is shown in Figure 2.9. The objectives of prototyping should be made explicit from the start of the process. These may be to develop a system to prototype the user interface, to validate functional system requirements, or to demonstrate feasibility.</p>
        </article>

        <article class="my-12 relative group">
            <img src="Chapter2-Images/Capture10.PNG"
                alt="Incremental Delivery"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                    grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110
                    group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.10: Incremental Delivery</p>
            <div class="div-img"></div>
        </article>

        <article class="text-lg md:text-xl text-justify space-y-4">
            <p>Developers are sometimes pressured by managers to deliver throwaway prototypes, particularly when there are delays in delivering the final version of the software. <b>However, this is usually unwise:</b></p>
            <br>
            <ol class="list-decimal list-inside space-y-2 mt-3">
                <li>It may be impossible to tune the prototype to meet non-functional requirements, such as performance, security, robustness, and reliability.</li>
                <li>Rapid change during development means that the prototype is undocumented, making long-term maintenance difficult.</li>
                <li>Frequent changes degrade the system structure, increasing maintenance costs.</li>
                <li>Quality standards are often relaxed for prototype development.</li>
            </ol>

            <p>Prototypes do not have to be executable to be useful. Paper-based mock-ups of the system user interface can be effective in helping users refine an interface design and work through usage scenarios. These are very cheap to develop and can be constructed in a few days. An extension of this technique is a <b>Wizard of Oz prototype</b> where only the user interface is developed. Users interact with this interface but their requests are interpreted manually.</p>
        </article>
    </section>

    <section id="section-2.3.2" class="main-sec4">

        <article class="mb-8">
            <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">2.3.2 Incremental Delivery</h1>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <p><b>Incremental delivery</b> (Figure 2.10) is an approach to software development where some of the developed increments are delivered to the customer and deployed for use in an operational environment. In this process, customers identify in outline the services to be provided by the system, prioritizing which services are most important. Several delivery increments are then defined, each providing a subset of system functionality. The highest-priority services are implemented and delivered first.</p>
            <br>
            <p>Once the system increments have been identified, the requirements for the services to be delivered in the first increment are defined in detail and that increment is developed. During development, further requirements analysis for later increments can take place, but requirements changes for the current increment are not accepted.</p>
            <br>
            <p>Once an increment is completed and delivered, customers can put it into service, allowing early delivery of part of the system functionality. This helps customers clarify their requirements for later increments. As new increments are completed, they are integrated with existing ones so that the system functionality improves with each delivery.</p>
        </article>

        <article class="text-lg md:text-xl text-justify mt-8">
            <p class="text-lg md:text-xl text-justify"><b>Incremental delivery has several advantages:</b></p>
            <ol class="list-decimal list-inside space-y-2 mt-3">
                <li>Customers can use early increments as prototypes and gain experience that informs requirements for later increments. These are part of the real system, so there is no re-learning when the final version arrives.</li>
                <li>Customers gain value early — the first increment satisfies their most critical requirements, allowing immediate software use.</li>
                <li>The process retains the flexibility of incremental development, making it easier to incorporate changes.</li>
                <li>High-priority services are delivered and tested first, reducing the risk of encountering failures in the most critical system areas.</li>
            </ol>
        </article>

        <article class="text-lg md:text-xl text-justify mt-8">
            <p class="text-lg md:text-xl text-justify"><b>However, there are challenges with incremental delivery:</b></p>
            <ol class="list-decimal list-inside space-y-2 mt-3">
                <li>Many systems require shared foundational facilities. Because requirements are defined incrementally, it can be difficult to identify common facilities early.</li>
                <li>Iterative development is hard for replacement systems, as users expect all old functionalities and may resist incomplete new systems.</li>
                <li>Incremental processes conflict with procurement models that require a full specification before contracting — common in large organizations like government agencies.</li>
            </ol>
        </article>

        <article class="text-lg md:text-xl text-justify mt-8 space-y-4">
            <p>Some systems are not suited for incremental development — for instance, very large distributed systems, embedded systems tied to hardware, or safety-critical systems that need complete requirement analysis for risk validation.</p>
            <br>
            <p>To gain some benefits of incremental development in these cases, teams may iteratively develop a <b>prototype</b> to experiment with system requirements and design. The insights gained then guide the creation of definitive system requirements.</p>
        </article>
    </section>

    <section id="section-2.3.3" class="main-sec4">

        <article class="mb-8">
            <h1 class="text-4xl font-bold text-orange-700 border-b-4 border-yellow-500 pb-3 hover:text-orange-800 transition-colors duration-300">2.3.3 Boehm’s Spiral Model</h1>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <p>A <b>risk-driven software process framework</b>, the Spiral Model, was proposed by Barry Boehm (1988). Illustrated in Figure 2.11, it represents the software process as a spiral rather than a simple sequence of activities. Each loop in the spiral corresponds to a phase — such as feasibility, requirements, design, or development — integrating change avoidance with change tolerance. It assumes that changes stem from project risks and explicitly includes risk management to minimize them.</p>
            <br>
            <p class="text-lg md:text-xl text-justify"><b>Each loop in the spiral is divided into four key sectors:</b></p>
        </article>

        <article class="my-12 relative group">
            <img src="Chapter2-Images/Capture11.PNG"
                alt="Boehm’s Spiral Model"
                class="mx-auto w-full md:w-4/5 shadow-lg rounded-2xl transition-all duration-700 ease-in-out
                    grayscale group-hover:grayscale-0 group-hover:scale-[1.03] group-hover:brightness-110
                    group-hover:shadow-2xl transform opacity-90 hover:opacity-100" />
                <p class="text-center text-sm text-amber-600 mt-3">Figure 2.11: Boehm’s Spiral Model of the Software Process</p>
            <div class="div-img"></div>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <ol class="list-decimal list-inside space-y-3 mt-3">
                <li><b>Objective setting:</b> Define specific objectives for that phase, identify constraints, create management plans, and outline potential risks with alternative strategies.</li>
                <li><b>Risk assessment and reduction:</b> Analyze each project risk in detail and take preventive steps — for example, developing a prototype to mitigate uncertain requirements.</li>
                <li><b>Development and validation:</b> Choose the best development model for the situation — e.g., throwaway prototyping for UI risks, formal methods for safety, or waterfall for integration concerns.</li>
                <li><b>Planning:</b> Review project progress and decide whether to proceed with the next loop of the spiral, creating detailed plans for the next iteration.</li>
            </ol>
        </article>

        <article class="text-lg md:text-xl text-justify mt-8 space-y-4">
            <p>The Spiral Model’s major distinction from other models is its <b>explicit recognition of risk</b>. Each cycle starts by defining objectives and constraints, then exploring alternatives to mitigate risks. These risks are resolved through information-gathering, prototyping, or simulation before moving to development.</p>
            <p>Once risks are assessed, the project proceeds with development followed by planning for the next iteration. Here, “risk” simply refers to anything that can go wrong — such as unreliable compilers, inefficient object code, or poor integration. Risk management, essential to project success, reduces potential schedule delays and cost overruns. This is explored further in <b>Chapter 22</b>.</p>
        </article>
    </section>

    <section id="section-2.4" class="main-sec4">
        <article class="mb-8">
            <h1 class="main-con">
                <a href="#section-2.4" class="text-4xl md:text-5xl font-extrabold text-orange-700 border-l-8 border-yellow-500 pl-5 leading-tight">2.4 The Rational Unified Process</a>
            </h1>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <p>The Rational Unified Process (RUP) (Krutchen, 2003) is an example of a modern process model that has been derived from work on the UML and the associated Unified Software Development Process (Rumbaugh, et al., 1999; Arlow and Neustadt, 2005). It is a good example of a hybrid process model that brings together elements from all the generic process models, illustrates good practice in specification and design, and supports prototyping and incremental delivery.</p>
            <br>
            <p><b>The RUP recognizes that conventional process models present a single view of the process. In contrast, the RUP is described from three perspectives:</b></p>
        </article>

        <article class="glass p-6 anim-fade mt-6">
            <ol class="text-lg md:text-xl text-justify">
                <li>A dynamic perspective, which shows the phases of the model over time.</li>
                <li>A static perspective, which shows the process activities that are enacted.</li>
                <li>A practice perspective, which suggests good practices to be used during the process.</li>
            </ol>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <p>Most descriptions of the RUP attempt to combine the static and dynamic perspectives in a single diagram (Krutchen, 2003). This makes the process harder to understand, so separate descriptions of each perspective are often clearer.</p>
            <br>
            <p>The RUP is a phased model that identifies four discrete phases in the software process. However, unlike the waterfall model where phases are equated with process activities, the RUP phases are more closely related to business rather than technical concerns. <b>These are:</b></p>
        </article>

        <article class="glass p-6 anim-fade mt-6">
            <ol class="text-lg md:text-xl text-justify">
                <li><b>Inception:</b> The goal of the inception phase is to establish a business case for the system. All external entities (people and systems) interacting with the system are identified, and these interactions are used to assess the system’s contribution to the business.</li>
                <br>
                <li><b>Elaboration:</b> The goals of the elaboration phase are to develop an understanding of the problem domain, establish an architectural framework, develop the project plan, and identify key project risks.</li>
                <br>
                <li><b>Construction:</b> The construction phase involves system design, programming, and testing. Parts of the system are developed in parallel and integrated during this phase.</li>
                <br>
                <li><b>Transition:</b> The final phase of the RUP is concerned with moving the system from development to the user community and ensuring it works in a real environment.</li>
            </ol>
        </article>

        <article class="my-8">
            <img src="Chapter2-Images/Capture12.PNG" alt="Rational Unified Model"
                class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
                <p class="text-center text-sm text-amber-600 mt-3"> Figure 2.12: Phases in Rational Unified Process</p>
        </article>

        <article class="text-lg md:text-xl text-justify">
            <p>Iteration within the RUP is supported in two ways: each phase may be enacted iteratively with results developed incrementally, and the entire set of phases may also be enacted incrementally, as shown by the looping arrow from Transition to Inception in Figure 2.12.</p>
            <br>
            <p>The static view of the RUP focuses on the activities (workflows) that take place during development. There are six core process workflows and three supporting workflows. The RUP is designed alongside UML, so its workflow descriptions are oriented around UML models such as sequence and object models.</p>
            <br>
            <p>The advantage of presenting dynamic and static views is that RUP workflows are not tied to specific phases — in principle, all workflows may be active at all stages. Early phases emphasize business modelling and requirements, while later phases focus on testing and deployment.</p>
            <br>
            <p>The practice perspective on the RUP describes good software engineering practices recommended for system development. <b>Six fundamental best practices are:</b></p>
        </article>

        <article class="my-8">
            <img src="Chapter2-Images/Capture13.PNG" alt="Static Workflow Rational Unified Model"
                class="rounded-2xl shadow-2xl mx-auto w-full md:w-3/4 hover:scale-105 hover:grayscale-0 grayscale transition-all duration-500 mt-6">
                 <p class="text-center text-sm text-amber-600 mt-3"> Figure 2.13: Static Workflows in the Rational Unified Process</p>
        </article>

        <article class="glass p-6 anim-fade">
            <ol class="list-decimal pl-6 mt-3 text-lg md:text-xl text-justify">
                <li><b>Develop software iteratively:</b> Plan system increments based on customer priorities and develop in manageable stages.</li>
                <li><b>Manage requirements:</b> Explicitly document and track customer requirements. Analyze change impact before acceptance.</li>
                <li><b>Use component-based architectures:</b> Structure system architecture into reusable and modular components.</li>
                <li><b>Visually model software:</b> Use graphical UML models to show static and dynamic system views.</li>
                <li><b>Verify software quality:</b> Ensure software meets organizational quality standards through testing and reviews.</li>
                <li><b>Control changes to software:</b> Manage software modifications with change and configuration management systems.</li>
            </ol>
        </article>

        <article class="text-lg md:text-xl text-justify mt-8">
            <p>The RUP is not suitable for all development types (e.g., embedded systems), but it effectively combines elements from the three generic process models. Its key innovations include separating phases from workflows and recognizing deployment as an essential part of the process. Phases are dynamic and goal-oriented, while workflows are static and technical, supporting all stages of development.</p>
        </article>
    </section>
</main>

<!-- Footer -->
<footer id="footer"
    class="relative clear-both bg-gradient-to-r from-orange-600 to-yellow-400 text-white mt-16 shadow-inner overflow-hidden transition-all duration-500">

    <div id="footer-filter"
        class="absolute inset-0 bg-black/10 backdrop-blur-[2px] transition-all duration-500 pointer-events-none"></div>

    <section class="relative max-w-7xl mx-auto px-6 py-12 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-12 fade-in text-left">

    <!-- Key Points -->
    <article>
        <h1 class="text-3xl font-extrabold mb-6 border-b-2 border-white pb-2">KEY POINTS</h1>
        <ol class="list-decimal list-inside space-y-3 text-white/90 text-justify leading-relaxed mb-8 text-sm md:text-base">
            <li>Software processes are the activities involved in producing a software system.</li>
            <li>General process models describe how software processes are organized.</li>
            <li>Requirements engineering develops software specifications for communication.</li>
            <li>Design and implementation turn requirements into executable systems.</li>
            <li>Validation checks that the system meets specifications and user needs.</li>
            <li>Evolution involves changing systems for new requirements.</li>
            <li>Processes should cope with change using iterative development.</li>
            <li>The Rational Unified Process organizes phases and separates key activities.</li>
        </ol>
    </article>

    <!-- Quick Navigation -->
    <article>
        <h1 class="text-3xl font-extrabold mb-6 border-b-2 border-white pb-2">QUICK NAVIGATION</h1>
        <div class="overflow-x-auto rounded-lg border border-white/30">
            <table class="min-w-full text-white/90 text-sm md:text-base">
            <tbody>
                <tr class="hover:bg-orange-800/30 transition">
                <td class="border border-white/30 px-4 py-2 font-bold">2.1</td>
                <td class="border border-white/30 px-4 py-2">
                    <a href="#section-2.1" class="hover:underline">Software Process Models</a>
                </td>
                </tr>

                <tr class="hover:bg-orange-800/30 transition">
                <td class="border border-white/30 px-4 py-2 font-bold">2.2</td>
                <td class="border border-white/30 px-4 py-2">
                    <a href="#section-2.2" class="hover:underline">Process Activities</a>
                </td>
                </tr>

                <tr class="hover:bg-orange-800/30 transition">
                <td class="border border-white/30 px-4 py-2 font-bold">2.3</td>
                <td class="border border-white/30 px-4 py-2">
                    <a href="#section-2.3" class="hover:underline">Coping With Change</a>
                </td>
                </tr>

                <tr class="hover:bg-orange-800/30 transition">
                <td class="border border-white/30 px-4 py-2 font-bold">2.4</td>
                <td class="border border-white/30 px-4 py-2">
                    <a href="#section-2.4" class="hover:underline">The Rational Unified Process</a>
                </td>
                </tr>
            </tbody>
            </table>
        </div>
    </article>

    <!-- Credits -->
    <article class="flex flex-col justify-between">
        <div>
            <h1 class="text-3xl font-extrabold mb-6 border-b-2 border-white pb-2">ABOUT</h1>
            <p class="text-white/90 text-justify leading-relaxed text-sm md:text-base">
            This educational module helps students understand the foundation and structure of software processes and their practical applications.
            </p>
        </div>

        <!-- Created By + Back to Top -->
        <div class="mt-8 border-t border-white/40 pt-4 flex items-center justify-between flex-wrap gap-4">
            <p class="text-sm md:text-base">
            Created by: <b>Mica Joyce Biadoy</b>
            </p>
            <a href="#top"
            class="bg-white/20 border border-white/40 px-4 py-2 rounded-md text-white font-semibold hover:bg-white/30 hover:translate-y-[-2px] transition-all duration-300">
            ↑ Back to Top
            </a>
        </div>
    </article>
    </section>

    <!-- Footer bottom bar -->
    <div class="relative bg-orange-700 text-center py-4 text-sm text-white/90">
        © 2025 Software Engineering Module | All Rights Reserved
    </div>
</footer>

</body>
</html>
